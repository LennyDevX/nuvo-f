{
  "contracts": {
    "StakingContract.sol": {
      "content": "pragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ncontract StakingContract is Ownable, Pausable {\n    using SafeMath for uint256;\n\n    uint256 public constant DURATION = 7 days;\n    uint256 public constant WEEKLY_ROI_PERCENTAGE = 5e2; // 5%\n    uint256 public constant HOURLY_ROI_PERCENTAGE = WEEKLY_ROI_PERCENTAGE / (7*24); // return per hour\n    uint256 public constant MAX_ROI_PERCENTAGE = 13500; // 135% \n    uint256 public constant COMMISSION_PERCENTAGE = 500; // 5%\n    uint256 public constant MAX_DEPOSIT = 10000 ether; // 10000 Matic \n\n    address public treasury;\n    uint256 public totalPoolBalance;\n \n    struct User {\n        uint256 totalDeposit;\n        uint256 lastClaimTime;\n        uint256 lastClaimBlock; // Nuevo campo para almacenar el último bloque de reclamo\n    }\n    mapping(address => User) private users;\n    mapping(address => uint256) public userRewards; \n\n    event DepositMade(address indexed user, uint256 amount, uint256 commission);\n    event RewardClaimed(address indexed user, uint256 amount);\n    event RewardWithdrawn(address indexed user, uint256 amount);\n    event ContractPaused(address indexed owner);\n    event ContractUnpaused(address indexed owner);\n    event BalanceAdded(uint256 amount);\n    event TreasuryUpdated(address indexed previousTreasury, address indexed newTreasury);\n\n    constructor(address _treasury) Pausable() Ownable() {\n        treasury = _treasury;\n    }\n\n    function setTreasury(address _newTreasury) external onlyOwner {\n        require(_newTreasury != address(0), \"New treasury address is the zero address\");\n        address previousTreasury = treasury;\n        treasury = _newTreasury;\n        emit TreasuryUpdated(previousTreasury, _newTreasury);\n    }\n\n    function deposit() public payable whenNotPaused {\n        require(msg.value <= MAX_DEPOSIT, \"Deposit exceeds the maximum\");\n        \n        uint256 commission = msg.value.mul(COMMISSION_PERCENTAGE).div(10000);\n        uint256 depositAmount = msg.value.sub(commission);\n        \n        totalPoolBalance = totalPoolBalance.add(depositAmount);\n\n        users[msg.sender].totalDeposit = users[msg.sender].totalDeposit.add(depositAmount);\n        users[msg.sender].lastClaimTime = block.timestamp;\n        users[msg.sender].lastClaimBlock = block.number; // Se establece el último bloque de reclamo\n\n        (bool success, ) = payable(treasury).call{value: commission}(\"\");\n        require(success, \"Failed to transfer commission\");\n\n        emit DepositMade(msg.sender, depositAmount, commission);\n    }\n\n    function getTotalDeposit(address user) public view returns(uint256) {\n        return users[user].totalDeposit;\n    }\n\n    function getLastClaimTime(address user) public view returns (uint256) {\n        return users[user].lastClaimTime;\n    }\n\n    function calculateRewards(address userAddress) public view returns(uint256) {\n        User storage user = users[userAddress];\n        uint256 blocksPassed = block.number - user.lastClaimBlock;\n        uint256 totalRewards = user.totalDeposit.mul(HOURLY_ROI_PERCENTAGE).div(10000).mul(blocksPassed);\n        \n        // Apply max ROI limit\n        uint256 maxReward = user.totalDeposit.mul(MAX_ROI_PERCENTAGE).div(10000);\n        if (totalRewards > maxReward) {\n            totalRewards = maxReward;\n        }\n        return totalRewards;\n    }\n\n    function claimRewards() public whenNotPaused {\n        User storage user = users[msg.sender];\n\n        uint256 totalRewards = calculateRewards(msg.sender);\n        uint256 commission = totalRewards.mul(COMMISSION_PERCENTAGE).div(10000);\n\n        require(totalPoolBalance >= totalRewards.add(commission), \"Not enough funds in the pool\");\n        require(totalRewards > 0, \"No rewards to claim\");\n\n        totalRewards = totalRewards.sub(commission);\n\n        totalPoolBalance = totalPoolBalance.sub(totalRewards.add(commission));\n\n        // Update last claim block\n        user.lastClaimBlock = block.number;\n\n        (bool success, ) = payable(treasury).call{value: commission}(\"\");\n        require(success, \"Failed to transfer commission\");\n        userRewards[msg.sender] = userRewards[msg.sender].add(totalRewards);\n\n        emit RewardClaimed(msg.sender, totalRewards);\n    }\n\n    function withdrawRewards() public whenNotPaused {\n        require(userRewards[msg.sender] > 0, \"No rewards to withdraw\");\n        uint256 reward = userRewards[msg.sender];\n        userRewards[msg.sender] = 0;\n\n        (bool success, ) = payable(msg.sender).call{value: reward}(\"\");\n        require(success, \"Failed to transfer rewards\");\n\n        emit RewardWithdrawn(msg.sender, reward); \n    }\n\n    function emergencyWithdraw(address to) public onlyOwner whenNotPaused {\n        (bool success, ) = to.call{value: address(this).balance}(\"\");\n        require(success, \"Emergency withdraw failed\");\n    }\n\n    function pause() public onlyOwner {\n        _pause();\n        emit ContractPaused(msg.sender);\n    }\n\n    function unpause() public onlyOwner {\n        _unpause();\n        emit ContractUnpaused(msg.sender);\n    }\n\n    function addBalance() public payable onlyOwner {\n        totalPoolBalance = totalPoolBalance.add(msg.value);\n        emit BalanceAdded(msg.value);\n    }\n\n    receive() external payable {}\n}\n"
    }
  }
}
